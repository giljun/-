# 제어자

## 패키지

- 클래스와 인터페이스의 집합을 의미
- 서로 관련이 있는 클래스나 인터페이스를 함께 묶음으로써 파일을 효율적으로 관리
- 협업 시, 서로 작업한 클래스 사이에서 발생할 수 있는 이름 충돌 문제까지도 해결
- 물리적으로 하나의 디렉토리를 의미
- 패키지는 다른 패키지를 포함할 수 있으며, 점(.)으로 구분



## 접근 제어자

- 제어자란 클래스와 클래스 멤버의 선언 시 사용하여 부가적인 의미를 부여하는 키워드
- 접근 제어자와 기타 제어자로 구분
- 기타의 경우, 여러 개를 함께 사용할 수도 있으나, 접근 제어자는 두 개 이상 같이 사용할 수는 없다.

- 정보 은닉이란 사용자가 굳이 알 필요가 없는 정보는 사용자로부터 숨겨야한다는 개념
- 사용자는 언제나 최소한 정보만으로 프록램을 손쉽게 사용할 수 있게 됩니다.
- private 접근 제어자
  - 외부에 공개되지 않으며, 직접 접근할 수 없다.
  - public 메소드를 통해서만 접근할 수 있다. 
- public 접근 제어자
  - 외부로 공개되며, 어디에서나 직접 접근할 수 있다.
  - public 메소드는 private 멤버와 프로그램 사이의 인터페이스 역할을 수행
- default 접근 제어자
  - 따로 존재하지 않으며, 접근 제어자가 지정되지 않으면 자동적으로 지정
  - 같은 클래스의 멤버와 같은 패키지에 속하는 멤버에서만 접근할 수 있다.
- protected 접근 제어자
  - 자바 클래스는 private 멤버로 정보를 은닉하고, public 멤버로 사용자나 프로그램과의 인터페이스를 구축
  - 부모 클래스에 대해서는 public 멤버처럼 취급되며, 외부에서는 private 멤버처럼 취급
    - 이 멤버를 선언한 클래스의 멤버
    - 선언한 클래스가 속한 패키지의 멤버
    - 상속받은 자식 클래스의 멤버



## 기타 제어자

- final 제어자
  - 변경할 수 없다는 의미로 사용
  - 필드나 지역 변수에 사용하면 값을 변경할 수 없는 상수가 된다.
  - 클래스에 사용하면 해당 클래스는 다른 클래스가 상속받을 수 없게 됩니다.
  - 메소드에 사용하면 해당 메소드는 오버라이딩을 통한 재정의를 할 수 없게 된다.
  - 사용할 수 있는 대상
    - 클래스, 메소드, 필드, 지역 변수
- static 제어자
  - 변수에 사용하면 해당 변수를 클래스 변수로 만들어준다.
  - 메소드에 사용하면, 클래스 메소드로 만들어준다.
  - static 제어자를 가지는 멤버는 다음과 같은 특징을 가지게 됩니다.
    - 프로그램 시작시 최초에 단 한 번만 생성되고 초기화됩니다.
    - 인스턴스를 생성하지 않고도 바로 사용할 수 있게 됩니다.
    - 해당 클래스의 모든 인스턴스가 공유합니다.
  - 사용할 수 있는 대상
    - 메소드, 필드, 초기화 블록
- abstract 제어자
  - 추상적인이라는 의미로 사용됩니다.
  - 선언부만 있고 구현부가 없는 메소드를 추상 메소드라 하며, 반드시 abstract 제어자를 붙여야 합니다.
  - 하나 이상의 추상 메소드가 포함하고 있는 추상 클래스도 반드시 abstract 제어자를 붙여야 합니다.



## 함께 사용할 수 없는 제어자

- 클래스에 final과 abstract는 함께 사용할 수 없습니다.
  - final 제어자를 가지는 클래스는 다른 클래스가 상속받을 수 없게 되며, 
  - abstract 제어자를 가지는 클래스는 다른 클래스가 상속해서 오버라이딩해야만 사용 가능하므로, 두 제어자는 클래스에 함께 사용할 수 없습니다.
- 메소드에 static과 abstract는 함께 사용할 수 없습니다.
  - abstract 제어자를 가지는 메소드는 선언부만 있고 구현부가 없는 메소드인데
  - static 제어자를 가지는 메소드는 인스턴스를 생성하지 않고도 바로 사용할 수 있어야 하므로, 함께 사용할 수 없습니다.
- 메소드에 private과 abstract는 함께 사용할 수 없습니다.
  - abstract 제어자를 가지는 메소드는 다른 클래스가 상속하여 오버라이딩해야만 사용할 수 있는데,
  - private 제어자를 가지는 메소드는 자식클래스에서 접근할 수 없게 되므로, 이 두 제어자는 함께 사용할 수 없습니다. 
- 메소드에 private과 final은 함께 사용할 수 없습니다.
  - 두 제어자 모두 해당 메소드가 오버라이딩을 통한 재정의를 할 수 없다는 의미를 가지므로, 둘 중 하나만 사용해도 의미가 충분히 전달될 수 있습니다.